# Базовый Javascript

⚠️ НЕ ОТПРАВЛЯЙТЕ ПУЛЛРЕКВЕСТЫ В ЭТОТ РЕПОЗИТОРИЙ ⚠️

## Общее описание задачи

Ваша задача — написать несколько функций, являющихся решением подзадач. Описания подзадач, а также инструкции по запуску тестов и отправке решений находятся ниже.

---

### **Сосчитай котов!**

![Count cats!](https://vg5b2ejdwb-flywheel.netdna-ssl.com/wp-content/uploads/2019/11/cats-in-boxes-03.jpg)  
Ваша задача — сосчитать котов, спрятавшихся на заднем дворе (представленном в виде двумерного массива, `Array`). Коты прячутся хорошо, но их **ушки** (`"^^"`) видны очень хорошо. Ваша задача — реализовать функцию `countCats(backyard)`, которая сосчитает котов. Удачи!

Число найденных котов должно иметь тип `number`. Если коты не найдены, функция должна вернуть `0`.

Например:

`countCats([
    [0, 1, '^^'],
    [0, '^^', 2],
    ['^^', 1, 2]
  ])` => `3`

Напишите ваш код в `src/count-cats.js`.

---

### **Углеродное датирование**

![Carbon dating](https://earthhow.com/wp-content/uploads/2018/12/Carbon-Dating-678x378.png)  
Для определения возраста археологических находок широко применяется **радиоизотопный анализ**. Один из его видов — **радиоуглеродный анализ**.

Примерный возраст образца рассчитывается при помощи измерения **соотношения** между **современной** активностью изотопа С14 и активностью этого же изотопа в **образце**.

[Почитайте о методе](https://chem.libretexts.org/Bookshelves/Physical_and_Theoretical_Chemistry_Textbook_Maps/Supplemental_Modules_(Physical_and_Theoretical_Chemistry)/Nuclear_Chemistry/Nuclear_Kinetics/Half-Lives_and_Radioactive_Decay_Kinetics#section_2)

---
<details>

  <summary>О расчетах</summary>
  Вы можете использовать формулу из статьи по ссылке выше. 0.693 — это приблизительное значение натурального логарифма двойки.

</details>

---

Ваша задача — реализовать функцию `dateSample(sampleActivity)`, которая рассчитывает примерный возраст образца (в годах). Пожалуйста, используйте данные `MODERN_ACTIVITY` и `HALF_LIFE_PERIOD`.

Параметр функции `sampleActivity` имеет тип `string`. Рассчитаный возраст образца должен иметь тип `number`. Возраст должен быть **целочисленным**. Возраст должен **округлен вверх** (при получении целого числа). В случае неправильного **типа** входного параметра или **несоответствующем** значении активности, или отсутствии аргумента функция должна вернуть `false`.

Например:

`dateSample('1')` => `22387` (либо `22392`, в зависимости от используемой формулы)

`dateSample('WOOT!')` => `false`

Напишите ваш код в `src/carbon-dating.js`.

---

### **Команда мечты**

![Dream team](https://i0.wp.com/www.comicsbeat.com/wp-content/uploads/2021/05/power-rangers.jpg?fit=1420,945&ssl=1)  
Представьте себе, что вы с вашими друзьями решаете создать **команду мечты**. Эта команда должна иметь крутое секретное название, в котором зашифрована информация о ней. Например, это могут быть **первые буквы** имен ее членов **в верхнем регистре**, **отсортированные по алфавиту**.

Ваша задача — реализовать функцию `createDreamTeam(members)`, которая возвращает имя только что созданной команды (`string`), основанной на именах ее членов (`array`). Удачи!

Имена членов команды должны быть типа `string`. Значения другого типа должны быть **проигнорированы**. В случае неправильного **типа** аргумента `members` функция должна вернуть `false`.

NB! Имя члена команды может содержать **пробелы**.

Например:

`createDreamTeam(['Matt', 'Ann', 'Dmitry', 'Max'])` => `'ADMM'`

`createDreamTeam(['Olivia', 1111, 'Lily', 'Oscar', true, null])` => `'LOO'`

Напишите ваш код в `src/dream-team.js`.

---

### **Какая пора года??**

![What season](https://images.twinkl.co.uk/tw1n/image/private/t_630_eco/image_repo/83/d2/T-T-224-four-seasons-posters-a4_ver_2.avif)  
Ваша задача — реализовать функцию `getSeason(date)`, которая принимает объект `Date` и возвращает соответствующую ему пору года. Пора года должна быть типа `string`.

---
<details>

<summary>Названия пор года в англиийском языке</summary>
В английском поры года имеют следующие наименования: весна — spring, лето — summer, осень — autumn (fall), зима — winter.

</details>

---

Если аргумент `date` не был передан, функция должна вернуть строку `'Unable to determine the time of year!'` Если аргумент `date` **некорректный**, функция должна выбросить ошибку (`Error`) с сообщением `Invalid date!`.

Тссс! Среди аргументов, которые попадают в эту функцию, затесался вражеский агент.

![Disguised](https://www.famousbirthdays.com/faces/disguised-toast-image.jpg)  
Он руководствуется знаменитой поговоркой: "Если это выглядит как **утка**, плавает как **утка**, и крякает как **утка**, тогда это, скорее всего, **утка** (и неважно, что это **на самом деле**)". Он **искусно маскируется** под настоящую дату (`date`), но умелый javascript-разработчик может поймать его и выбросить ошибку с сообщением `Invalid date!` как раз вовремя!

Например:

`const springDate = new Date(2020, 02, 31)`

`getSeason(springDate)` => `'spring'`

Напишите ваш код в `src/what-season.js`.

---

### **Ханойская башня**

![Визуализация алгоритма](https://ioecapsule.com/wp-content/uploads/2019/08/tower_of_hanoi_3_disks.gif)  
[Ханойская башня](https://www.britannica.com/topic/Tower-of-Hanoi) — знаменитая математическая головоломка 18 столетия.
Она состоит из трех стержней и некоторого числа дисков разных размеров, которые могут быть надеты на стержень. Головоломка начинается с того, что диски расположены друг на друге, причем наименьший расположен сверху. Диски образуют конус.

Цель головоломки — переместить всю стопку на другой стержень, следуя этим простым **правилам**:
* перемещать можно только **один** диск за раз
* можно брать только **верхний** диск с одной из стопок и помещать на **верхушку** другой стопки или на пустой стержень
* диск **большего** размера нельзя класть на диск **меньшего** размера

Ваша задача значительно легче, чем придумывать алгоритм, решающий эту задачу :)

Реализуйте функцию `calculateHanoi`, которая принимает параметры `diskNumber` и `turnsSpeed`. `diskNumber` — это число **дисков**, а `turnsSpeed` — скорость перемещения дисков (в **ходах** в **час**). Оба параметра являются числами (тип `number`)

Функция `calculateHanoi` возвращает объект с 2 свойствами:
* `turns` (минимальное число (тип `number`) ходов, необходимое для решения головоломки)
* `seconds` (минимальное число (тип `number`) **секунд**, необходимое для решения головоломки при заданной скорости; должно быть целым числом, полученным в результате округления результата расчетов в меньшую **(floor)** сторону)

Вам не нужно валидировать входные параметры.

Например:

`calculateHanoi(9, 4308)` => `{ turns: 511, seconds: 427 }`

Напишите ваш код в `src/hanoi-tower.js`.

---

### **Преобразование массива**

![Transform array](https://www.capturehighered.com/wp-content/uploads/2019/02/The-Call-720x332.jpg)  
Ваша задача — реализовать функцию `transform(arr)`, которая принимает массив (тип `array`) и возвращает **преобразованный** массив, основываясь на **управляющих последовательностях**, которые содержит `arr`. **Управляющие последовательности** — это определенные строковые элементы вышеупомянутого массива:
* `--discard-next` исключает следующий за ней элемент исходного массива из преобразованного массива.
* `--discard-prev` исключает предшествующий ей элемент исходного массива из преобразованного массива.
* `--double-next` удваивает следующий за ней элемент исходного массива в преобразованном массиве.
* `--double-prev` удваивает предшествующий ей элемент исходного массива в преобразованном массиве.

Например:

`transform([1, 2, 3, '--double-next', 4, 5])` => `[1, 2, 3, 4, 4, 5]`

`transform([1, 2, 3, '--discard-prev', 4, 5])` => `[1, 2, 4, 5]`

Функция не должна изменять исходный массив. Управляющие последовательности применяются **последовательно, слева направо** к элементам из исходного массива. Управляющие последовательности **не попадают** в преобразованный массив. Управляющие последовательности в исходном массиве не встречаются подряд (не следуют одна за другой). Если около управляющей последовательности **нет элемента**, к которому она может быть применена в исходном массиве, либо он был удален в процессе преобразования массива, **она не делает ничего**. Функция должна выбросить ошибку с сообщением `'arr' parameter must be an instance of the Array!`, если `arr` не является массивом.

Напишите свой код в `src/transform-array.js`.

---

### **Чейнмейкер**

![Chaining](https://www.sdxcentral.com/cdn-cgi/image/w=748,h=374,fit=scale-down,f=auto,q=30/https://www.sdxcentral.com/wp-content/uploads/2018/08/Why-Problems-With-Service-Chaining-Are-Stalling-NFV.jpg)  
Давайте попрактикуемся в [чейнинге](https://en.wikipedia.org/wiki/Method_chaining)!

Ваша задача — реализовать объект `chainMaker`, который будет создавать цепочки. Оконченная цепочка это строка (тип `string`) и выглядит следующим образом: `'( value1 )~~( value2 )~~( value3 )'`.

`chainMaker` имееет несколько **методов** для создания цепочек и их модификации:
* `getLength` возвращает текущую длину цепи в виде числа;
* `addLink(value)` добавляет звено, содержащее строковое представление `value` к цепочке;
* `removeLink(position)` удаляет звено цепи, находящееся в заданном положении;
* `reverseChain` разворачивает цепь задом наперед;
* `finishChain` завершает цепь и **возвращает** ее.

Методы `addLink`, `reverseChain` и `removeLink` **чейнятся**, в то время как остальные – нет. Если `addLink` вызван без аргументов, он добавляет пустое звено (`'(  )'`) в цепочку. Если `removeLink` принимает **некорректную** позицию (например, не являющуюся числом, или дробное число, или ссылающуюся на несуществующее звено), он должен выбросить **ошибку** с сообщением `You can't remove incorrect link!`. После вызова метода `finishChain` существующая на данный момент цепь должна быть удалена, как и в случае, если была выброшена **ошибка**.

Например:

`chainMaker.addLink(1).addLink(2).addLink(3).finishChain()` => `'( 1 )~~( 2 )~~( 3 )'`

`chainMaker.addLink(1).addLink(2).removeLink(1).addLink(3).finishChain()` => `'( 2 )~~( 3 )'`

`chainMaker.addLink(1).addLink(2).reverseChain().addLink(3).finishChain()` => `'( 2 )~~( 1 )~~( 3 )'`

Напишите ваш код в `src/simple-chain.js`.

---

### **Рекурсивный вычислитель глубины**

![Идти глубже](https://i.imgur.com/k7lADiM.jpg)  
Ваша задача — реализовать класс `DepthCalculator` с методом `calculateDepth`, который принимает массив и возвращает его **глубину**.

Метод `calculateDepth` должен проходить полученный массив **рекурсивно**. Глубина **плоского** массива — 1. Метод должен корректно работать с массивами, не содержащими элементов или содержащими пустые массивы.

Например:

`const depthCalc = new DepthCalculator();`

`depthCalc.calculateDepth([1, 2, 3, 4, 5])` => `1`

`depthCalc.calculateDepth([1, 2, 3, [4, 5]])` => `2`

`depthCalc.calculateDepth([[[]]])` => `3`

Напишите ваш код в `src/recursive-depth.js`.

---
### **Расширенный повторитель**

![Extended repater](https://farm5.staticflickr.com/4683/39024400961_732f449b65.jpg)  
Ваша задача — реализовать функцию `repeater(str, options)`.
Эта функция возвращает повторяющуюся **строку**, основываясь на заданных параметрах:
*	`str` это **строка**, которая будет повторена
*	`options` это **объект** опций, который содержит следующие свойства:
  -	`repeatTimes` устанавливает число повторений `str`
  - `separator` это строка, разделяющая повторения `str`
  - `addition` это дополнительная строка, которая будет добавлена после каждого повторения `str`
  - `additionRepeatTimes` устанавливает число повторений `addition`
  - `additionSeparator` это строка, разделяющая повторения `addition`

Параметры `str` и `addition` по умолчанию являются **строками**. В случае, если они другого типа, он должны быть преобразованы к строке.
 
Параметры `separator` и `additionSeparator` являются строками.

`repeatTimes` и `additionRepeatTimes` являются целыми числами (в случае отсутствия любого из них соответствующая строка не повторяется).

Единственный обязательный параметр — это `str`, остальные могут не быть переданы.
Значение `separator` по умолчанию это `'+'`. Значение `additionSeparator` по умолчанию это `'|'`.

Например: `repeater('STRING', { repeatTimes: 3, separator: '**', addition: 'PLUS', additionRepeatTimes: 3, additionSeparator: '00' })` => `'STRINGPLUS00PLUS00PLUS**STRINGPLUS00PLUS00PLUS**STRINGPLUS00PLUS00PLUS'`

Напишите свой код в `src/extended-repeater.js`.

---

### **Шифр Виженера**

![Ciphering machine](https://live.staticflickr.com/1931/44960892745_471bee66bb_b.jpg)  
Криптография — это здорово! Давайте попробуем наладить производство шифровальных машин. Наши машины будут использовать один из методов шифрования, которые легки для понимания, но не могут быть разгаданы посредством простого криптоанализа — [**шифр Виженера**](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher).

Наша машина будет иметь 2 модификации: **прямая** и **обратная** (тип машины определяется в момент создания). **Прямая** машина просто шифрует и дешифрует строку, переданную в нее, а **обратная** машина возвращает **перевернутую** задом наперед строку после шифрования и дешифрования.

Ваша задача — реализовать класс `VigenereCipheringMachine`. `constructor` этого класса принимает `true` (**или ничего**), чтобы создать **прямую** машину и `false`, чтобы создать **обратную** машину.
Каждый экземляр `VigenereCipheringMachine` должен иметь 2 метода: `encrypt` и `decrypt`.

Метод `encrypt` принимает 2 параметра: `message` (строка, чтобы ее зашифровать) и `key` (строку-кодовое слово).

Метод `decrypt` принимает 2 параметра: `message` (строка, чтобы ее расшифровать) и `key` (строку-кодовое слово)

Эти параметры для обоих методов являются **обязательными**. Если хотя бы один из них не был передан, должна быть выброшена ошибка с сообщением `Incorrect arguments!`. Машины шифруют и дешифруют **только символы латинского алфавита** (другие символы не изменяются). Строка, возвращаемая этими методами, должна иметь **верхний регистр**.

Вам не нужно валидировать значение, переданное в `contructor` и в методы `encrypt` и `decrypt` (за исключением выбрасывания ошибки при отсутствии аргумента для для этих методов).

Например:

`const directMachine = new VigenereCipheringMachine();`

`const reverseMachine = new VigenereCipheringMachine(false);`

`directMachine.encrypt('attack at dawn!', 'alphonse')` => `'AEIHQX SX DLLU!'`

`directMachine.decrypt('AEIHQX SX DLLU!', 'alphonse')` => `'ATTACK AT DAWN!'`

`reverseMachine.encrypt('attack at dawn!', 'alphonse')` => `'!ULLD XS XQHIEA'`

`reverseMachine.decrypt('AEIHQX SX DLLU!', 'alphonse')` => `'!NWAD TA KCATTA'`

Напишите свой код в `src/vigenere-cipher.js`.

---

### **(ST) Сосчитать общие символы**
Ваша задача — реализовать функцию, которая принимает 2 **строки** (`s1` и `s2`) и возвращает **число** их общих символов.

Например:

`getCommonCharacterCount('aabcc', 'adcaa')` => `3`

Напишите свой код в `src/st-common-character-count.js`.

---

### **(ST) Удалить цифру**
Ваша задача — реализовать функцию, которая принимает **целое число** (`n`) и возрващает **максимальное число**, котороые можно получить путем удаления **ровно одной цифры** из данного числа.

Например:

`deleteDigit(152)` => `52`

Напишите свой код в `src/st-delete-digit.js`.

---

### **(ST) Доменные имена**
Ваша задача — реализовать функцию, которая принимает **массив** доменов (`domains`) и возвращает **объет** с имеющимися в нем DNS.

Например:

`getDNSStats(['code.yandex.ru', 'music.yandex.ru', 'yandex.ru'])` => `{'.ru': 3, '.ru.yandex': 3, '.ru.yandex.code': 1,'.ru.yandex.music': 1}`

Напишите свой код в `src/st-dns-stats.js`.

---

### **(ST) Закодируйте строку**

Ваша задача — реализовать функцию, которая принимает **строку** (`str`) и возвращает ее закодированную версию.

Например:

`encodeLine('aabbbc')` => `'2a3bc'`

Напишите свой код в `src/st-encode-line.js`.

---

### **(ST) Имена файлов**
Дан список файлов, и поскольку файлы не могут иметь одинаковых имен, те из них, которые создаются позже, будут иметь суффикс **(k)**, где k — наименьшее **целое число**, которое не использовалось с данным именем файла.
Ваша задача — реализовать функцию, которая принимает **массив** имен (`names`) и возвращает **массив** имен, которые будут даны файлам.

Например:

`renameFiles(["file", "file", "image", "file(1)", "file"])` => `["file", "file(1)", "image", "file(1)(1)", "file(2)"]`

Напишите свой код в `src/st-file-names.js`.

---

### **(ST) Получить домен электронной почты**
Ваша задача — реализовать функцию, которая принимает адрес электронной почты (`email`) и возвращает его **домен**.

Например:

`getEmailDomain('prettyandsimple@example.com')` => `'example.com'`

Напишите свой код в `src/st-get-email-domain.js`.

---

### **(ST) MAC-48 адрес?**
MAC-48 адрес — это шесть групп по 2 шестнадцатеричные цифры (от 0 до 9 или от A до F), разделенных дефисами.
Ваша задача — реализовать функцию, которая принимает строку (`inputString`) и возвращает `true`, если строка является валидным MAC-48 адресом.

Например:

`isMAC48Address('00-1B-63-84-45-E6')` => `true`

Напишите свой код в `src/st-mac-adress.js`.

---

### **(ST) Сумма элементов матрицы**
Дана прямоугольная **матрица** **целых чисел**, просто сложите все значения, которые **не находятся под 0**.

Например:

```
const matrix = [
 [0, 1, 1, 2],
 [0, 5, 0, 0],
 [2, 0, 3, 3]
];

getMatrixElementsSum(matrix) => 9
```

Напишите свой код в `src/st-matrix-elements-sum.js`.

---

### **(ST) Сапёр**
В популярной игре "Сапёр" у вас есть поле с некоторым количеством мин и каждая клетка имеет число, которое показывает совокупное число мин в соседних с ней клетках.
Получив поле с расставленными на нем минами (`true` — мина есть, `false` — мины нет) нам нужно создать поле игры "Сапёр".

Например:

```
const matrix = [
 [true, false, false],
 [false, true, false],
 [false, false, false]
];

minesweeper(matrix) => [
 [1, 2, 1],
 [2, 1, 1],
 [1, 1, 1]
];
```

Напишите свой код в `src/st-mine-sweeper.js`.

---

### **(ST) Отссортировать по высоте**
Дан массив с высотами, отсортируйте его, за исключением значений `-1`.
Ваша задача — реализовать функцию, которая принимает **массив** (`arr`) и возвращает его **отсортированным**.

Например:

`sortByHeight([-1, 150, 190, 170, -1, -1, 160, 180])` => `[-1, 150, 160, 170, -1, -1, 180, 190]`

Напишите свой код в `src/st-sort-by-height.js`.

---

### **(ST) Сумма цифр**
Ваша задача — реализовать функцию, которая принимает **число** (`n`) и возвращает **сумму его цифр**, пока не получится **число из одной цифры**.

Например:

Для 100 результат должен быть 1 (1 + 0 + 0 = 1)  
`getSumOfDigits(100)` => `1`
Для 91, результат также должен быть 1 (9 + 1 = 10, 1 + 0 = 1)  
`getSumOfDigits(91)` => `1`

Напишите свой код в `src/st-sum-digits.js`.

---

Напишите свой код в `src/st-queue.js`.

---

#### Предварительные шаги
1. Установите [Node.js](https://nodejs.org/en/download/)   
2. Сделайте форк этого репозитория: https://github.com/AlreadyBored/basic-js
3. Склонируйте себе этот репозиторий: https://github.com/<%your_github_username%>/basic-js/  
4. Перейдите в папку `basic-js`  
5. Вбейте в командную строку [`npm install`](https://docs.npmjs.com/cli/install) для установки зависимостей  
6. Выполните `npm run test` в командой строке.
7. Вы увидите число ожидающих (pending), проходящих и падающих тестов. 100% проходящие тесты сооветствуют максимальному баллу за задание.

---

#### Отправка в [rs app](https://app.rs.school)
1. Откройте [rs app](https://app.rs.school) и залогиньтесь
2. Перейдите на страницу отправки задания
3. Выберите задание (BasicJS)
4. Нажмите кнопку "Submit"

---

#### Внимание!
1. Рекомендуется использовать 12.x.x LTS версию Node.js. Если вы используете фичи, которые не поддерживаются 12 версией, могут быть проблемы с автопроверкой задания.
2. Перед отправкой результата убедитесь, что каждый ваш тест проходит не более чем за 30 секунд.

---

© [AlreadyBored](https://github.com/alreadybored)  
& задачи с префиксом `st-` интегрированы из [Short track 2021 repo](https://github.com/rkhaslarov/rs-school-short-track-2021)

& Thanks [mikhama](https://github.com/mikhama) for assistance!
